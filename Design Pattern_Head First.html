1. Strategy Pattern - Define the algorithm and encapsulate each of them. And make it reusable. Con is you can change the algorithm apart from Client.
2. Observer Pattern - one to many dependencies. Waiting for one object to reach the others
3. Decorator Pattern - Enables you to add functions dynamically by sublcassing.
4. Factory Pattern - Subclass takes charge of creating instance then send it up.
5. Singleton Pattern - Single instance object. better use volitile  and static for instance to prevent mutithread. the instance must be declared private.
6. Command Pattern - You can encapsulte the order and can add extra order in parameter. Also, you can save order in queue or in log or cancel.
7. Adapter Pattern - When there are two classes implementing two different interfaces, it can change the interface type.
8. Facade Pattern - Provides a unified interface to a set of interfaces in a subsystem. Facade defines a highlevel interface that makes the subsystem easier to use.
