<!DOCTYPE html>
<html lang="en">
<head>Learn Algorithm in C
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body><<hi>Learn Algorithm in C by Jaegyu Lee</h1>
  <ol>
    <li><h2>Basis of Algorithm</h2></li>
    <ul>
      <li>Euclideans Algorithm</li>
      <li>Prime Number Algorithm</li>
    </ul>

    <li><h2>Data Structure</h2></li>
      <ul>
        <li>Array</li>
        <li>Maze Shortest Path</li>
        <li>Linked List</li>
        <li>Stack</li>
        <li>Queue</li>
        <li>Tree</li>
      </ul>

    <li><h2>Sorting</h2></li>
      <ul>
        <li>Selection Sort</li>
        <li>Insertion Sort</li>
        <li>Bubble Sort</li>
        <li>Shell Sort</li>
        <li>Distribution Counting</li>
        <li>Quick Sort</li>
        <li>Radix Sort</li>
        <li>Heap Sort</li>
        <li>Merge Sort</li>
        <li>External Sort</li>
      </ul>
    <li><h2>Search</h2></li>
      <ul>
        <li>Sequential Search</li>
        <li>Binary Search</li>
        <li>Binary Tree Search</li>

        <li>Balanced Search Tree</li>
          1. AVL
          2. 2-3 Tree
          3. 2-3-4 Tree
          4. Red-Black Tree
          5.
        <li>Hash</li>
        <li>Radix Search</li>
        Binary Redix Tree
        Radix Trie Search
      </ul>

    <li><h2>Graph</h2></li>
      <ul>
        <li>Basis of Graph</li>
        Graph is consist of Vertex and Edge. the way they are connected is called Path.
        when the graph is connected perfectly with paths, it's called Complete graph. if not, when it's not in a cycle structure, it's called Spanning Tree
        Sometimes it has ways, for example from up to down, most cases in search trees, but Grah doesn't really
        have the ways until it's designated. undesignated form is called Indireted Gragh and the other is Directed Gragh or Digraph.
        in addition, weighted graph is mixed with one of them. it's called Network
        <li>Tricks of Graph</li>
        There are two mainly used ways of implementing graph in C first, Adjacency Matrix the other
        Adjacency List.
        Adjacency Matrix may take more than enough memory but it's easy to look and understand.
        if the number of Vertex is x. then it will be V * V Matrix and it's indicated 0 and 1 by connectivity(or relationship)
        Adjacency List is similar to Hash By Chain. The number of connection is needed by the number of Vertex and components are added by the conectivity.
        <li>Search</li>
        Depth First Search, DFS, and Breadth First Search, BFS, are mainly used ways to search in graph.
        First one goes by where it is connected to the next. but most of the time Vertex are not connected perfectly.
        Therefore, it misses some of vertex and when it reaches the deadend, it checks the rest not visited yet. That way it makes Spanning Tree.
        Breadth first search is conducted like stacks. it goes throw all the level thoroughly to the bottom.
        <li>Biconnectivity</li>
        Think about Vertex A, B, C and D A,b,c are all connected to each other but D is connected to only C then when C is disposed, D has no way to reach A
        So C is a Articulation Point. Articulation Point is a critical issue when it comes to NetWork. since it has to reach every points simultaneoulsy.
        <li>Representation of Set</li>
        One way to find a minimum cost spanning tree is Priority queue search From a root, find every nodes(vertices) and by queue,
        find the next nodes sequencely. Another way is Kruska Algorithm. Set two roots, where its original root and the bottom.
        Shortest Path problem might be the most general issues you'd face in field. Find the prices to get to the next vertex. and calculate them to
        the destination. Dijkstra Algorithm is one way to do it.
        <li>Directed Graph</li>
        Transitive Closure == Reachability. Depth first Search is used for this. Warshall Algorithm is also useful. it must both
        way connected.
        Floyd Algorithm is for finding all shortest paths. It repeats Dijkstra's algorithm for V times.
        Topological Sorting represents sequantial works. A needs to do C,D and E work first to do F work. Also it can't be
        cycle.
        <li>NetWork</li>
        Ford-Fulkerson Algorithm. it's design to find the maximum flow in network. Each edge has weight (in this case the capacity of flow)
        Breadth First search needs to be implemented then Augmenting Path.
        <li></li>
      </ul>




  </ol>

</body>
</html>
