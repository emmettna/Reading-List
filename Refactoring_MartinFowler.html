<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Refactoring by Martin Fowler</title>
</head>
<body>
  <h1>Refactoring by Martin Fowler</h1>
    <ul>
      <li>Chapter 1</li>
        <p>1. Ugly and too long codes(unnecessarilly) prone to cause mistakes and bugs
          impossible to reuse. Which means, it will be difficult to change the code when
          your client askes some changes.</p>
        <p>2. Make a solid test unit in advance of refactoring.</p>
        <p>3. First target is overly long statement method. Extract methods
          then don't forget to run the test after changes.</p>
        <p>4. After split massive methods into chunks change the variables</p>
        <p>5. a method should be on the object whoses data it uses</p>
        <p>6. get rid of temp variables and locally scoped variables as much as you canvas</p>
        <p>7. replacing temp variables with queries is another great option.</p>
        <p>8. Switch statement better stay with the origin of values (migrate the method to
          the class holds the data.)</p>
        <p>9. Replace type code with State/strategy</p>
        <p>10. Extract Method, Move Method and Replace conditions with Polymorphism</p>
      <li>Chapter 2</li>
        <p>1. When you refactor there are to steps. Change the codes and add functions
          Don't try to add function and change the code at the same time. It will end up
          impossible code to look up</p>
        <p>2. without refctoring, even good codes can lose it's design. Programming is saying
          what your device to respond. if you want it to answer correctly. Better say it clearly</p>
        <p>3. So when to refactor? When you add new function, reported bugs and when you review the codes</p>
        <p>4. Many cases your project is coupled with Database, put a middle layer so when you change code,
          you don't need to change codes in database.</p>
        <p>5. Interface is treakier to deal with. let the old codes connect to new code. so peope using the interface
          won't have to change.</p>
        <p>6. when it comes to performance, small tiny code is not the solution. try the overall codes.</p>
      <li>Chapter 3</li>
        <p>1. Duplicated code is the first smell implying you should kick start refactoring. Common simplest
        mistakes are written two same method in one class and next one is between siblings(which obviously you
         can pull it to parent class)</p>
        <p>Long method with explanation added is a good idea but the best is making the method short so anybody can
          understand.</p>
        <p>Large class often  shows up that too many variales </p>
        <p>Divergent change is one class that suffers many kinds of changes, and shotgun surgery is one
          change that alters many classes.</p>
        <p> Data items tend to be like children. they hang around together. probably good way to
          break this up is extract class on the fields. Reducing field lists and parameter lists will remove
          some bad smells.</p>
        <p>Lazy class which doens't pay much role, probably it did its job before after refactoring it doens't do enough
           work to get it's class title, then collapse the hierarchy. </p>
        <p>Long comments actually means bad codes. Because it needs to explain imperfect codes.</p>
      <li>Chapter 4</li>
        <p>Every Class needs a method that tests its class. Operated automatically</p>
        <p> There is also framework you can run test automatically</p>
        <p>Unit test is assuming the other whole is working fine and Fuctional Test is testing the entire work.</p>
        <p>When testing. Think of the boundary conditions</p>
      <li>Chapter 5-6</li>
        <p>Write a name and summaries and so on for Format of the refactoring. Like draw a sketch of what you are going to do </p>
        <p>When temporary variables are just too tangled to replace, re place Method with Method object </p>
        <p>Name the method by what it does not by how it does</p>
        <p>While extracting method, when you have to return two variables, you can arrange mutiple methods to return one value</p>
        <p>A good practice to replace local variable to query is, put the variable in Final then test first.</p>
        <p>Replace Method with Method object by mean, turn all these local variables into fields on the method object</p>
      <li>Chapter 7</li>
        <p>When moving a method, Probably better moving a clutch rather than just one since they are coupled and declare the
          method name more reasonable </p>
      <li>Chaper 8</li>
        <p>Arrays are common structure for organizing data. but if the elements are not related to each other,
          Replace Arrays with objects. Encapsulation is a bonus.</p>
        <p>Replace Magic number with Symbolic Constant</p>
        <p>Replace type code with subclasses is primarily a scaffolding move that enables Replace conditional with
          Polymorphism. if there is no conditional statement, replace type code with class is the better and less critical move</p>
      <li>Chapter 9</li>
        <p>One of the most common areas of complexity in a program lies in complex conditional logic</p>
        <p>Rather use break or continue than control flag. If can't, extract logic into a method and return.</p>
        <p>When flipping condition, mind the operators if (a&&b)==if(!a||b)</p>
      <li>Chapter 10</li>
        <p>Good way of renaming is what you'd comment and make it the name. Remember your code is for a Human first a computer second</p>
        <p>Replace Error Code with Exception </p>
        <p>Replace exception with Test codes which you might trigger up front</p>
      <li>Chapter 11</li>
        <p>a Pulled up method can get setter and getter when it's used, probably better use abstract getter since the use of origin were different </p>
        <p>Super class is a good choice for mutiple common behaviors but superclass can be only one. if need more, consider using interface.</p>
        <p>if two subclasses have a similar method but not exactly the same, Use templates</p>
      <li>Chapter 12</li>
        <p>Four big steps for Big refactorings. Tease Apart Inheritance, Convert Prodedural Design to Objects, Separate Domain from Presentation and Extract Hierarchy</p>
        <p>When dealing with tangled inheritance hierarchy,Don't be afraid one step back, and make right classes for the tree and go two step forward by deleting the uncetain classes</p>
        <p> </p>
    </ul>

  <h3>Appendix</h3>
  UML - Unified Medeling Language
  Factory Method - it hides creating a new object
</body>
</html>
